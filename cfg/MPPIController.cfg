#!/usr/bin/env python
# MPPI Controller configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params
PACKAGE = "mppi_controller"

gen = ParameterGenerator()

# Reuse existing parameter definitions that concern all local planners
add_generic_localplanner_params(gen)

gen.add("visualize", bool_t, 0, "Visualize MPPI trajectories", True)
gen.add("controller_frequency", double_t, 0, "Controller frequency", 30.0, 0.1, 100.0)

grp_robot = gen.add_group("Robot", type="tab")
grp_robot.add("vx_max", double_t, 0, "Max VX (m/s)", 0.5, 0.0, 100.0)
grp_robot.add("vy_max", double_t, 0, "Max VY (m/s)", 0.5, 0.0, 100.0)
grp_robot.add("vx_min", double_t, 0, "Min VX (m/s)", -0.35, -10.0, 0.0)
grp_robot.add("vy_min", double_t, 0, "Min VY (m/s)", 0.5, 0.0, 10.0)
grp_robot.add("wz_max", double_t, 0, "Max WZ (rad/s)", 1.9, 0.0, 10.0)
grp_robot.add("vx_std", double_t, 0, "Sampling standard deviation for VX", 0.2, 0.0, 4.0)
grp_robot.add("vy_std", double_t, 0, "Sampling standard deviation for VY", 0.2, 0.0, 4.0)
grp_robot.add("wz_std", double_t, 0, "Sampling standard deviation for WZ", 0.4, 0.0, 4.0)

motion_model_enum = gen.enum([
    gen.const("DiffDrive", int_t, 0, "DiffDrive robots"),
    gen.const("Omni", int_t, 1,
              "Omni robots"),
    gen.const("Ackermann", int_t, 2, "Ackermann car-like robots"),
], "Motion model")
grp_robot.add("motion_model", int_t, 0, "Robot kinematics model", 0, 0, 2, edit_method=motion_model_enum)

grp_optimization = gen.add_group("Optimization", type="tab")
grp_optimization.add("model_dt", double_t, 0, "Time interval (s) between two sampled points in trajectories", 0.05, 0.001, 1.0)
grp_optimization.add("time_steps", int_t, 0, "Number of time steps (points) in each sampled trajectory", 56, 1, 1000)
grp_optimization.add("batch_size", int_t, 0, "Count of randomly sampled candidate trajectories", 1000, 1, 5000)
grp_optimization.add("iteration_count", int_t, 0, "Iteration count in MPPI algorithm. Recommend to keep as 1 and prefer more batches", 1, 1, 10)
grp_optimization.add("temperature", double_t, 0, "Selectiveness of trajectories by their costs; 0 mean use control with best cost, huge value will lead to just taking mean of all trajectories without cost consideration", 0.3, 0.0, 100)
grp_optimization.add("gamma", double_t, 0, "A trade-off between smoothness (high) and low energy (low)", 0.1, 0.0, 1.0)
grp_optimization.add("retry_attempt_limit", int_t, 0, "Number of attempts to find feasible trajectory on failure for soft-resets before reporting failure", 1, 1, 10)



exit(gen.generate(PACKAGE, "mppi_controller", "MPPIController"))
